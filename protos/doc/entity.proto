syntax = "proto2";

package doc.entity;

import "ocr/types.proto";

/* Raw OCR Data.
	 Analagous to how machine-words in memory are just bytes, the interpretation
	 of RawData is determined by its type flag.

	 Useful if we want to support custom types?
 */
message RawPayload {
	// Need to think about how the 'type' string communicates how 'data' field
	// should be decoded in an arbitrary application using Foundation types.
	required string type = 1;
	required bytes data = 2;
}

message Entity {
	reserved 16;
	oneof payload {
		OcrWord ocr_word = 1;
		Line line = 2;
		Paragraph paragraph = 3;
		TableCell table_cell = 4;
		TableRow table_row = 5;
		Table table = 6;
		Word word = 7;
		Phrase phrase = 8;
		Number number = 9;
		Integer integer = 10;
		Date date = 11;
		Currency currency = 12;
		Name name = 13;
		Address address = 14;
		NamedNLP named_nlp = 15;
		RawPayload custom = 17;
	}
}

message OcrWord {
	required ocr.InputWord word = 1;
}

message Line {
	repeated ocr.InputWord ocr_words = 1;
}

message Paragraph {
	repeated Line lines = 1;
}

message TableCell {
	// A TableCell should support heterogeneous content?
	repeated RawPayload content = 1;
}

message TableRow {
	repeated TableCell cells = 1;
}

message Table {
	repeated TableRow rows = 1;
}

/* What follows are NLP entities?

	 I don't know if going this approach makes things harder or not...
 */

/* A Word is not the same as an OcrWord.

	 Words are a semantic type, and only make sense under interpretation.
	 For example, we may want to handle OCR errors which split natural language
	 words into multiple OCR Objects.
 */
message Word {
	repeated ocr.InputWord components = 1;
	optional double score = 2 [default = -1.0];
	// should we keep a transformed object?
}

/* A Phrase is not the same as a Line.

	 Phrases are semantic types, and make sense in a natural language context.
*/
message Phrase {
	repeated Word words = 1;
	optional double score = 2 [default = -1.0];

}

/* -------------------------------------------------------------------
   These are essentially NER types... but can be useful to distinguish
   from something that's explicitly output by an NER model?
   -------------------------------------------------------------------
*/


message Number {
	repeated ocr.InputWord components = 1;
	optional double score = 2 [default = -1.0];
}

message Integer {
	repeated ocr.InputWord components = 1;
	optional double score = 2 [default = -1.0];
}

message Date {
	repeated ocr.InputWord components = 1;
	optional double score = 2 [default = -1.0];
}

message Currency {
	repeated ocr.InputWord components = 1;
	optional double score = 2 [default = -1.0];
}

message Name {
	repeated Word names = 1;
	optional double score = 2 [default = -1.0];
}

message Address {
	// If we want to support single-line addresses, or non-cluster addresses
	// Then Phrase makes sense here?
	repeated Phrase lines = 1;
	optional double score = 2 [default = -1.0];
}

message NamedNLP {
	repeated Word words = 1;
	optional double score = 2 [default = -1.0];
	optional string label = 3;
}

